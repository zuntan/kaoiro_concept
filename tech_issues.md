# 技術課題と解決策 (tech_issues.md)

`kaoiro` プロトタイプおよびコンセプト設計フェーズで判明した技術的な障壁と、本番実装における具体的な解決アプローチ。

## 1. ジェスチャー判定のロバスト性 (誤検知対策)

### 1.1. 顔の前後移動 (Z-Axis) の誤認
- **課題**: 従来の単純な座標変化検知では、顔をカメラに近づけた際（拡大）に、放射状に広がる座標移動を「頷き（Y軸移動）」や「首振り（X軸移動）」と誤認する。
- **解決策**: **幾何学的正規化 (Geometric Normalization)** を徹底する。
    - **基準単位**: 「両目の距離 ($W_{eyes}$」を1.0とする単位系に変換する。顔が近づけば $W_{eyes}$ も大きくなるため、デプスニュートラライゼーション後の移動量はキャンセルされる。
    - **相対ベクトル**: 顔の移動（平行移動）ではなく、「顔面基準プレーン（目・口）」に対する「鼻先の相対位置」の変化のみを監視する。
    - **Z軸抑制**: $W_{eyes}$ の変化率（時間微分）が閾値を超えた場合（＝急激に近づいている最中）は、全てのジェスチャー判定を強制的にロックする。

### 1.2. 意図しない微細な動き (Micro-movements)
- **課題**: 人間は静止しているつもりでも常に微細に動いている（不随意運動）。また、Webカメラ特有のノイズ（ジッター）が乗る。
- **解決策**:
    - **EMAフィルタ**: 指数移動平均 ($\alpha \approx 0.1 \sim 0.3$) を適用し、高周波ノイズを除去する。
    - **インテントスタビライザー (Intent Stabilizer) 閾値**: 判定開始（ON）の閾値を高く、判定解除（OFF）の閾値を低く設定するシュミットトリガ回路的なロジックを組む。
    - **チャタリング防止**: 一度判定が確定したら、1.5秒間は入力を受け付けないクールダウン期間を設ける。

## 2. リアルタイム画像処理とプライバシー

### 2.1. Privacy View (PiP) の描画負荷
- **課題**: 生映像を「認識できなくする」加工（ぼかし、エッジ抽出）はCPU負荷が高い。特に `Gaussian Blur` はカーネルサイズに比例して重くなる。
- **解決策**:
    - **縮小処理**: 加工前に画像を 1/4 〜 1/8 に縮小する。ぼかし処理は縮小画像に対して行い、表示時に拡大する（バイリニア補間）ことで、擬似的に強力なぼかしを低負荷で実現する。
    - **エッジ描画**: OpenCVの `Canny` ではなく、Face Detector が出力した顔アンカー (KaoAnchor) 座標を結んで「ワイヤーフレーム」を描画する。これなら画像処理ではなく単なる2Dベクター描画（`egui::Painter`）で済むため、極めて軽量。

### 2.2. GUI描画 (egui) の最適化
- **課題**: カメラフレーム（640x480 @ 30fps）を毎回 `egui` のテクスチャに転送すると、バス帯域とメモリコピーのコストが発生する。
- **解決策**:
    - **Texture Reuse**: `egui::TextureHandle` を保持し、`set_image` で中身だけを差し替える。毎回 `load_texture` を呼ばない。
    - **条件付き描画**: 設定パネルが閉じている（PiPのみ表示）場合は、PiP用の小さなテクスチャのみを更新し、全画面分のデータ転送をスキップする。

## 3. アセット管理と配布 (Single Binary)

### 3.1. 外部ファイルの依存排除
- **課題**: ONNXモデルファイル、アイコンSVG、フォントファイルなどを実行ファイルと同じ場所に置く必要があると、配布やパス設定が面倒になる。
- **解決策**: **`include_bytes!` マクロによる埋め込み**。
    - 全てのリソースをバイナリ内に静的にリンクする。
    - `ort` (ONNX Runtime) のモデル読み込みも `load_from_memory` APIを使用する。
    - これにより、ユーザーは `.exe` (またはバイナリ) 1つをダウンロードするだけで動作する。

## 4. クロスプラットフォーム対応

### 4.1. カメラデバイスへのアクセス (Linux/Windows/macOS)
- **課題**: OSごとにカメラAPIが異なる（V4L2, MediaFoundation, AVFoundation）。
- **解決策**: **`nokhwa` クレートの採用**。
    - 各OSのバックエンドを抽象化してくれる。
    - ただし、Linux (Wayland) 環境では権限周りやウィンドウシステムとの兼ね合いでカメラ列挙に失敗することがあるため、`v4l` バックエンドを明示的に指定する等のフォールバック処理を実装する。

### 4.2. 設定保存パスの差異
- **課題**: `~/.config` や `%APPDATA%` など、OSごとの作法に従う必要がある。
- **解決策**: **`directories` クレート** を使用する。
    - `ProjectDirs::from("com", "kaoiro", "kaoiro")` で、OSに準拠した適切な設定ディレクトリパス（Config, Data, Cache）を取得する。

### 4.3. ブラウザ拡張機能版のパフォーマンス制約
プロトタイプ検証 (`kaoiro_proto`) で判明した、Webブラウザ環境特有の課題。

- **SIMDの必須性**: 標準WASMでは推論速度が 1〜2 FPS 程度に留まる。
    - **対策**: `.cargo/config.toml` で `simd128` を有効化し、`tract` や `ort` が内部でSIMD命令を使えるようにする。これにより 7〜9 FPS まで改善する。
- **メインスレッドのフリーズ**: 推論処理（約100ms）をメインスレッドで行うとUIが完全に停止する。
    - **対策**: 推論ロジックを **Dedicated Worker** に分離し、`postMessage` で非同期に通信する。
    - **通信コスト**: 画像データの転送コストを抑えるため、`SharedArrayBuffer` または `Transferable Objects` を活用する。
- **マルチスレッドの壁**: ネイティブのように `std::thread` が自由に使えない。
    - **対策**: `wasm-bindgen-rayon` 等を用いて、Workerプール上で並列計算を行う仕組みを構築する必要がある。

## 5. 将来的な拡張性 (Future Works)

### 5.1. 機械学習モデルの軽量化
- **課題**: 将来的に MLStrategy (RNN/CNN) を導入する場合、推論エンジンのサイズ増大と推論時間の増加が懸念される。
- **解決策**:
    - **TFLite / ONNX Quantization**: モデルを量子化（int8）し、サイズと計算量を削減する。
    - **Burn / Candle**: Rustネイティブの学習・推論フレームワークを採用し、ONNX Runtime (C++バインディング) への依存を排除する可能性も視野に入れる。
